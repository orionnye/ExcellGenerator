{"ast":null,"code":"import _asyncIterator from\"/Users/ConScholar/Projects/Training/BigData/ExcelGenerator/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";import{useState,useCallback}from'react';export const useFolderScanner=()=>{const[folderData,setFolderData]=useState(null);const[isScanning,setIsScanning]=useState(false);const[error,setError]=useState(null);const scanFolder=useCallback(async folderPath=>{setIsScanning(true);setError(null);try{let files=[];let actualPath='';if(folderPath instanceof FileSystemDirectoryHandle){// Use File System Access API\nactualPath=folderPath.name;files=await scanDirectoryHandle(folderPath);}else{// Manual path input - this would need a backend service\n// For now, we'll show an error for manual paths\nthrow new Error('Manual path input requires a backend service. Please use the folder picker button.');}const newFolderData={path:actualPath,fileCount:files.length,files:files,lastScanned:new Date()};setFolderData(newFolderData);}catch(err){setError(err instanceof Error?err.message:'Failed to scan folder');}finally{setIsScanning(false);}},[]);const resetFolder=useCallback(()=>{setFolderData(null);setError(null);},[]);return{folderData,isScanning,error,scanFolder,resetFolder};};// Helper function to recursively scan a directory handle\nasync function scanDirectoryHandle(directoryHandle){let relativePath=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'';const files=[];try{var _iteratorAbruptCompletion=false;var _didIteratorError=false;var _iteratorError;try{for(var _iterator=_asyncIterator(directoryHandle.entries()),_step;_iteratorAbruptCompletion=!(_step=await _iterator.next()).done;_iteratorAbruptCompletion=false){const[name,handle]=_step.value;{const fullPath=relativePath?\"\".concat(relativePath,\"/\").concat(name):name;if(handle.kind==='file'){files.push(fullPath);}else if(handle.kind==='directory'){// Recursively scan subdirectories\nconst subFiles=await scanDirectoryHandle(handle,fullPath);files.push(...subFiles);}}}}catch(err){_didIteratorError=true;_iteratorError=err;}finally{try{if(_iteratorAbruptCompletion&&_iterator.return!=null){await _iterator.return();}}finally{if(_didIteratorError){throw _iteratorError;}}}}catch(error){console.error(\"Error scanning directory \".concat(relativePath,\":\"),error);// Continue scanning other files/directories even if one fails\n}return files;}","map":{"version":3,"names":["useState","useCallback","useFolderScanner","folderData","setFolderData","isScanning","setIsScanning","error","setError","scanFolder","folderPath","files","actualPath","FileSystemDirectoryHandle","name","scanDirectoryHandle","Error","newFolderData","path","fileCount","length","lastScanned","Date","err","message","resetFolder","directoryHandle","relativePath","arguments","undefined","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_asyncIterator","entries","_step","next","done","handle","value","fullPath","concat","kind","push","subFiles","return","console"],"sources":["/Users/ConScholar/Projects/Training/BigData/ExcelGenerator/src/hooks/useFolderScanner.ts"],"sourcesContent":["import { useState, useCallback } from 'react';\nimport { FolderData } from '../types/FolderData';\n\nexport const useFolderScanner = () => {\n\tconst [folderData, setFolderData] = useState<FolderData | null>(null);\n\tconst [isScanning, setIsScanning] = useState(false);\n\tconst [error, setError] = useState<string | null>(null);\n\n\tconst scanFolder = useCallback(async (folderPath: string | FileSystemDirectoryHandle) => {\n\t\tsetIsScanning(true);\n\t\tsetError(null);\n\t\t\n\t\ttry {\n\t\t\tlet files: string[] = [];\n\t\t\tlet actualPath: string = '';\n\n\t\t\tif (folderPath instanceof FileSystemDirectoryHandle) {\n\t\t\t\t// Use File System Access API\n\t\t\t\tactualPath = folderPath.name;\n\t\t\t\tfiles = await scanDirectoryHandle(folderPath);\n\t\t\t} else {\n\t\t\t\t// Manual path input - this would need a backend service\n\t\t\t\t// For now, we'll show an error for manual paths\n\t\t\t\tthrow new Error('Manual path input requires a backend service. Please use the folder picker button.');\n\t\t\t}\n\t\t\t\n\t\t\tconst newFolderData: FolderData = {\n\t\t\t\tpath: actualPath,\n\t\t\t\tfileCount: files.length,\n\t\t\t\tfiles: files,\n\t\t\t\tlastScanned: new Date()\n\t\t\t};\n\t\t\t\n\t\t\tsetFolderData(newFolderData);\n\t\t} catch (err) {\n\t\t\tsetError(err instanceof Error ? err.message : 'Failed to scan folder');\n\t\t} finally {\n\t\t\tsetIsScanning(false);\n\t\t}\n\t}, []);\n\n\tconst resetFolder = useCallback(() => {\n\t\tsetFolderData(null);\n\t\tsetError(null);\n\t}, []);\n\n\treturn {\n\t\tfolderData,\n\t\tisScanning,\n\t\terror,\n\t\tscanFolder,\n\t\tresetFolder\n\t};\n};\n\n// Helper function to recursively scan a directory handle\nasync function scanDirectoryHandle(\n\tdirectoryHandle: FileSystemDirectoryHandle,\n\trelativePath: string = ''\n): Promise<string[]> {\n\tconst files: string[] = [];\n\t\n\ttry {\n\t\tfor await (const [name, handle] of directoryHandle.entries()) {\n\t\t\tconst fullPath = relativePath ? `${relativePath}/${name}` : name;\n\t\t\t\n\t\t\tif (handle.kind === 'file') {\n\t\t\t\tfiles.push(fullPath);\n\t\t\t} else if (handle.kind === 'directory') {\n\t\t\t\t// Recursively scan subdirectories\n\t\t\t\tconst subFiles = await scanDirectoryHandle(handle, fullPath);\n\t\t\t\tfiles.push(...subFiles);\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\tconsole.error(`Error scanning directory ${relativePath}:`, error);\n\t\t// Continue scanning other files/directories even if one fails\n\t}\n\t\n\treturn files;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback } from 'react';\nexport const useFolderScanner = () => {\n  _s();\n  const [folderData, setFolderData] = useState(null);\n  const [isScanning, setIsScanning] = useState(false);\n  const [error, setError] = useState(null);\n  const scanFolder = useCallback(async folderPath => {\n    setIsScanning(true);\n    setError(null);\n    try {\n      let files = [];\n      let actualPath = '';\n      if (folderPath instanceof FileSystemDirectoryHandle) {\n        // Use File System Access API\n        actualPath = folderPath.name;\n        files = await scanDirectoryHandle(folderPath);\n      } else {\n        // Manual path input - this would need a backend service\n        // For now, we'll show an error for manual paths\n        throw new Error('Manual path input requires a backend service. Please use the folder picker button.');\n      }\n      const newFolderData = {\n        path: actualPath,\n        fileCount: files.length,\n        files: files,\n        lastScanned: new Date()\n      };\n      setFolderData(newFolderData);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to scan folder');\n    } finally {\n      setIsScanning(false);\n    }\n  }, []);\n  const resetFolder = useCallback(() => {\n    setFolderData(null);\n    setError(null);\n  }, []);\n  return {\n    folderData,\n    isScanning,\n    error,\n    scanFolder,\n    resetFolder\n  };\n};\n\n// Helper function to recursively scan a directory handle\n_s(useFolderScanner, \"Litx6ijD2m8vwLm5/yApjvyZ/KI=\");\nasync function scanDirectoryHandle(directoryHandle, relativePath = '') {\n  const files = [];\n  try {\n    for await (const [name, handle] of directoryHandle.entries()) {\n      const fullPath = relativePath ? `${relativePath}/${name}` : name;\n      if (handle.kind === 'file') {\n        files.push(fullPath);\n      } else if (handle.kind === 'directory') {\n        // Recursively scan subdirectories\n        const subFiles = await scanDirectoryHandle(handle, fullPath);\n        files.push(...subFiles);\n      }\n    }\n  } catch (error) {\n    console.error(`Error scanning directory ${relativePath}:`, error);\n    // Continue scanning other files/directories even if one fails\n  }\n  return files;\n}","map":{"version":3,"names":["useState","useCallback","useFolderScanner","_s","folderData","setFolderData","isScanning","setIsScanning","error","setError","scanFolder","folderPath","files","actualPath","FileSystemDirectoryHandle","name","scanDirectoryHandle","Error","newFolderData","path","fileCount","length","lastScanned","Date","err","message","resetFolder","directoryHandle","relativePath","handle","entries","fullPath","kind","push","subFiles","console"],"sources":["/Users/ConScholar/Projects/Training/BigData/ExcelGenerator/src/hooks/useFolderScanner.ts"],"sourcesContent":["import { useState, useCallback } from 'react';\nimport { FolderData } from '../types/FolderData';\n\nexport const useFolderScanner = () => {\n\tconst [folderData, setFolderData] = useState<FolderData | null>(null);\n\tconst [isScanning, setIsScanning] = useState(false);\n\tconst [error, setError] = useState<string | null>(null);\n\n\tconst scanFolder = useCallback(async (folderPath: string | FileSystemDirectoryHandle) => {\n\t\tsetIsScanning(true);\n\t\tsetError(null);\n\t\t\n\t\ttry {\n\t\t\tlet files: string[] = [];\n\t\t\tlet actualPath: string = '';\n\n\t\t\tif (folderPath instanceof FileSystemDirectoryHandle) {\n\t\t\t\t// Use File System Access API\n\t\t\t\tactualPath = folderPath.name;\n\t\t\t\tfiles = await scanDirectoryHandle(folderPath);\n\t\t\t} else {\n\t\t\t\t// Manual path input - this would need a backend service\n\t\t\t\t// For now, we'll show an error for manual paths\n\t\t\t\tthrow new Error('Manual path input requires a backend service. Please use the folder picker button.');\n\t\t\t}\n\t\t\t\n\t\t\tconst newFolderData: FolderData = {\n\t\t\t\tpath: actualPath,\n\t\t\t\tfileCount: files.length,\n\t\t\t\tfiles: files,\n\t\t\t\tlastScanned: new Date()\n\t\t\t};\n\t\t\t\n\t\t\tsetFolderData(newFolderData);\n\t\t} catch (err) {\n\t\t\tsetError(err instanceof Error ? err.message : 'Failed to scan folder');\n\t\t} finally {\n\t\t\tsetIsScanning(false);\n\t\t}\n\t}, []);\n\n\tconst resetFolder = useCallback(() => {\n\t\tsetFolderData(null);\n\t\tsetError(null);\n\t}, []);\n\n\treturn {\n\t\tfolderData,\n\t\tisScanning,\n\t\terror,\n\t\tscanFolder,\n\t\tresetFolder\n\t};\n};\n\n// Helper function to recursively scan a directory handle\nasync function scanDirectoryHandle(\n\tdirectoryHandle: FileSystemDirectoryHandle,\n\trelativePath: string = ''\n): Promise<string[]> {\n\tconst files: string[] = [];\n\t\n\t\ttry {\n\t\t\tfor await (const [name, handle] of directoryHandle.entries()) {\n\t\t\t\tconst fullPath = relativePath ? `${relativePath}/${name}` : name;\n\t\t\t\t\n\t\t\t\tif (handle.kind === 'file') {\n\t\t\t\t\tfiles.push(fullPath);\n\t\t\t\t} else if (handle.kind === 'directory') {\n\t\t\t\t\t// Recursively scan subdirectories\n\t\t\t\t\tconst subFiles = await scanDirectoryHandle(handle as FileSystemDirectoryHandle, fullPath);\n\t\t\t\t\tfiles.push(...subFiles);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error(`Error scanning directory ${relativePath}:`, error);\n\t\t\t// Continue scanning other files/directories even if one fails\n\t\t}\n\t\n\treturn files;\n}\n"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,WAAW,QAAQ,OAAO;AAG7C,OAAO,MAAMC,gBAAgB,GAAGA,CAAA,KAAM;EAAAC,EAAA;EACrC,MAAM,CAACC,UAAU,EAAEC,aAAa,CAAC,GAAGL,QAAQ,CAAoB,IAAI,CAAC;EACrE,MAAM,CAACM,UAAU,EAAEC,aAAa,CAAC,GAAGP,QAAQ,CAAC,KAAK,CAAC;EACnD,MAAM,CAACQ,KAAK,EAAEC,QAAQ,CAAC,GAAGT,QAAQ,CAAgB,IAAI,CAAC;EAEvD,MAAMU,UAAU,GAAGT,WAAW,CAAC,MAAOU,UAA8C,IAAK;IACxFJ,aAAa,CAAC,IAAI,CAAC;IACnBE,QAAQ,CAAC,IAAI,CAAC;IAEd,IAAI;MACH,IAAIG,KAAe,GAAG,EAAE;MACxB,IAAIC,UAAkB,GAAG,EAAE;MAE3B,IAAIF,UAAU,YAAYG,yBAAyB,EAAE;QACpD;QACAD,UAAU,GAAGF,UAAU,CAACI,IAAI;QAC5BH,KAAK,GAAG,MAAMI,mBAAmB,CAACL,UAAU,CAAC;MAC9C,CAAC,MAAM;QACN;QACA;QACA,MAAM,IAAIM,KAAK,CAAC,oFAAoF,CAAC;MACtG;MAEA,MAAMC,aAAyB,GAAG;QACjCC,IAAI,EAAEN,UAAU;QAChBO,SAAS,EAAER,KAAK,CAACS,MAAM;QACvBT,KAAK,EAAEA,KAAK;QACZU,WAAW,EAAE,IAAIC,IAAI,CAAC;MACvB,CAAC;MAEDlB,aAAa,CAACa,aAAa,CAAC;IAC7B,CAAC,CAAC,OAAOM,GAAG,EAAE;MACbf,QAAQ,CAACe,GAAG,YAAYP,KAAK,GAAGO,GAAG,CAACC,OAAO,GAAG,uBAAuB,CAAC;IACvE,CAAC,SAAS;MACTlB,aAAa,CAAC,KAAK,CAAC;IACrB;EACD,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMmB,WAAW,GAAGzB,WAAW,CAAC,MAAM;IACrCI,aAAa,CAAC,IAAI,CAAC;IACnBI,QAAQ,CAAC,IAAI,CAAC;EACf,CAAC,EAAE,EAAE,CAAC;EAEN,OAAO;IACNL,UAAU;IACVE,UAAU;IACVE,KAAK;IACLE,UAAU;IACVgB;EACD,CAAC;AACF,CAAC;;AAED;AAAAvB,EAAA,CApDaD,gBAAgB;AAqD7B,eAAec,mBAAmBA,CACjCW,eAA0C,EAC1CC,YAAoB,GAAG,EAAE,EACL;EACpB,MAAMhB,KAAe,GAAG,EAAE;EAEzB,IAAI;IACH,WAAW,MAAM,CAACG,IAAI,EAAEc,MAAM,CAAC,IAAIF,eAAe,CAACG,OAAO,CAAC,CAAC,EAAE;MAC7D,MAAMC,QAAQ,GAAGH,YAAY,GAAG,GAAGA,YAAY,IAAIb,IAAI,EAAE,GAAGA,IAAI;MAEhE,IAAIc,MAAM,CAACG,IAAI,KAAK,MAAM,EAAE;QAC3BpB,KAAK,CAACqB,IAAI,CAACF,QAAQ,CAAC;MACrB,CAAC,MAAM,IAAIF,MAAM,CAACG,IAAI,KAAK,WAAW,EAAE;QACvC;QACA,MAAME,QAAQ,GAAG,MAAMlB,mBAAmB,CAACa,MAAM,EAA+BE,QAAQ,CAAC;QACzFnB,KAAK,CAACqB,IAAI,CAAC,GAAGC,QAAQ,CAAC;MACxB;IACD;EACD,CAAC,CAAC,OAAO1B,KAAK,EAAE;IACf2B,OAAO,CAAC3B,KAAK,CAAC,4BAA4BoB,YAAY,GAAG,EAAEpB,KAAK,CAAC;IACjE;EACD;EAED,OAAOI,KAAK;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}